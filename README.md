ComPortMonitor

Драйвер уровня ядра, позволяющий прослушивать данные проходящие через COM-порт. Моя первая и последняя попытка написания драйвера. Использует Kernel Mode Driver Framework (KMDF), чтобы собрать драйвер соответственно нужно установить данный фреймворк. Писал очень давно, отладил, но до ума не довёл. В частности, так и не разобрался как написать установщик драйвера. При отладке Visual Studio сама деплоила драйвер на тестовую виртуалку. Клиентское приложение не сохранилось, оно вообще было написано ещё на Delphi и также не было доведено до ума.

В общем суть работы драйвера: при загрузке система вызывает DriverEntry, в котором драйвер инициализирует требуемые объекты, в частности список прослушиваемых устройств. Далее система добавляет подходящие по классу устройства, вызывая метод ComPortMonitorEvtDeviceAdd драйвера, вставляя в стек драйверов устройства указатель на драйвер. Так как это не полноценный драйвер, а драйвер-фильтр, ниже по стеку есть настоящий драйвер порта, которому мы просто передаём запросы к нему и ответы от него в обратную сторону, попутно записывая содержимое если у нас подключено одно или несколько клиентских приложений. В файле Queue.c собственно обработка команд.

ComPortMonitorEvtIoRead - тут получаем команду на чтение из порта, так как драйвер-фильтр находится выше по стеку основного драйвера, то любые команды фильтр получает раньше чем основной драйвер, и данных из порта при обработки нет, суть метода в том, чтобы установить метод, который будет вызван по удовлетворении запроса (основным драйвером) методом WdfRequestSetCompletionRoutine и отправить запрос вниз по стеку для дальнейшей обработки методом WdfRequestSend. И уже по окончании обработки, получим вызов метода ComPortMonitorCompletionRoutine, где уже будут данные, прочитанные с порта, которые можно записать себе для дальнейшей передачи подслушивающему приложению.
ComPortMonitorEvtIoWrite - тут получаем команду на запись в порт. Данные для записи уже есть, всё просто: данные записали себе, запрос передали дальше.
ComPortMonitorEvtIoDeviceControl - тут обрабатываются команды IoDeviceControl, всё то что нельзя отнести к категории записи или чтения, то есть различные управляющие команды. Их не мониторим, просто передаём запрос дальше.

В файле Control.c описана логика работа с подслушивающим приложением.
CreateControlDevice - тут создаём устройство - интерфейс взаимодействия подслушивающего приложения с драйвером.
ControlDevice_EvtDeviceFileCreate - метод вызывается системой при подключении подслушивающего приложения к нашему устройству-интерфейсу.
ControlDevice_EvtFileClose - соответственно вызывается при отключении приложения.
ControlDevice_EvtIoDeviceControl - обрабатываем управляющие вызовы подслушивающего приложения:
IOCTL_CPM_GET_DEVICE_FIRST - получаем первый доступный к прослушиванию порт
IOCTL_CPM_GET_DEVICE_NEXT - получаем следующий доступный к прослушиваюнию порт
Когда список портов закончился, возвращается код ошибки STATUS_NO_MORE_ENTRIES
IOCTL_CPM_ATTACH_TO_DEVICE - команда к началу прослушки нужного порта
IOCTL_CPM_DETACH_FROM_DEVICE - команда к окончанию прослушки нужного порта
IOCTL_CPM_GET_DATA_INFO - получить метаданные о захваченных данных, в частности размер данных, чтобы подготовить буфер нужного размера, куда эти данные будут прочитаны. Если захваченные данные на момент поступления запроса есть, то запрос удовлетворяется сразу. Если нет - запрос отправляется в очередь методом WdfRequestForwardToIoQueue, подслушивающее приложение при этом "висит" на вызове, дожидаясь поступления новых данных.
IOCTL_CPM_GET_DEVICE_PROCESS_ID - предполагалась возможность получить ID процесса, открывшего порт, но похоже не реализовано.

Выложил, чтобы возможно кто-нибудь доведёт до ума, написал инсталлер и клиентское (подслушивающее) приложение. Ну и ещё в интернете очень мало готовых примеров рабочих драйверов, возможно кому-то сойдёт в качестве примера.